<!DOCTYPE html>
<html>
<head>
  <title>MOON GOAT!</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      position: relative;
      background: black;
      color: white;
      font-family: Arial, sans-serif;
    }
    #canvas {
      display: block;
      background: black;
      display: none; /* hidden initially */
    }
    .btn {
      position: fixed;
      bottom: 20px;
      width: 100px;
      height: 60px;
      font-size: 20px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid white;
      border-radius: 8px;
      user-select: none;
      touch-action: manipulation;
    }
    #jumpBtn {
      left: 20px;
      display: none; /* hidden initially */
    }
    #restartBtn {
      right: 20px;
      display: none; /* hidden initially */
    }
    #menu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      max-height: 90vh;         /* Prevent menu from growing too tall */
      overflow-y: auto;         /* Allow scrolling if content is too tall */
      padding: 10px;
      box-sizing: border-box;
      width: 240px;             /* Fixed width for consistent button alignment */
    }
    #menu h1 {
      font-size: 48px;
      margin-bottom: 40px;
      letter-spacing: 4px;
      color: white;             /* Ensure title is visible */
    }
    .level-btn {
      display: block;
      margin: 12px auto;
      padding: 12px 30px;
      font-size: 20px;          /* Slightly smaller font */
      border: 2px solid white;
      border-radius: 10px;
      background: rgba(0,0,0,0.6);
      color: white;
      cursor: pointer;
      width: 100%;              /* Full width inside menu */
      max-width: 200px;         /* Limit max width */
      user-select: none;
      transition: background 0.3s, color 0.3s;
    }
    .level-btn:hover {
      background: white;
      color: black;
    }
  </style>
</head>
<body>

  <div id="menu">
    <h1>MOON GOAT</h1>
    <button class="level-btn" data-level="mars">Mars</button>
    <button class="level-btn" data-level="moon">Moon</button>
    <button class="level-btn" data-level="earth">Earth</button>
    <button class="level-btn" data-level="sun">Sun</button>
    <button class="level-btn" data-level="asteroid">Asteroid Belt</button>
  </div>

  <canvas id="canvas" width="640" height="480"></canvas>
  <button id="jumpBtn" class="btn">Jump</button>
  <button id="restartBtn" class="btn">Restart</button>

<script>
  var isGameStarted = false;
  var currentLevel = null;

  var canvas = document.getElementById("canvas");
  var ctx = canvas.getContext("2d");

  var goatImg = new Image();
  goatImg.src = "moongoatgoat.png";

  // Stars
  var starCount = 100;
  var stars = [];

  function initStars() {
    stars = [];
    for (let i = 0; i < starCount; i++) {
      stars.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        radius: Math.random() * 1.2 + 0.3,
        alpha: Math.random(),
        alphaChange: (Math.random() * 0.02) + 0.005,
      });
    }
  }

  function drawStars() {
    for (let star of stars) {
      star.alpha += star.alphaChange;
      if (star.alpha >= 1 || star.alpha <= 0.2) star.alphaChange *= -1;

      ctx.beginPath();
      ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(255,255,255," + star.alpha.toFixed(2) + ")";
      ctx.fill();
    }
  }

  // Shooting stars
  var shootingStars = [];
  var shootingTimer = 0;

  function spawnShootingStar() {
    shootingStars.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height / 2,
      vx: -4 - Math.random() * 2,
      vy: 2 + Math.random() * 2,
      length: 80 + Math.random() * 40,
      alpha: 1,
    });
  }

  function updateShootingStars() {
    shootingTimer++;
    if (shootingTimer > 120 + Math.random() * 100) {
      spawnShootingStar();
      shootingTimer = 0;
    }

    for (let star of shootingStars) {
      star.x += star.vx;
      star.y += star.vy;
      star.alpha -= 0.01;
    }

    shootingStars = shootingStars.filter(s => s.alpha > 0);
  }

  function drawShootingStars() {
    for (let star of shootingStars) {
      const grad = ctx.createLinearGradient(star.x, star.y, star.x + star.length, star.y - star.length / 2);
      grad.addColorStop(0, "rgba(255,255,255," + star.alpha + ")");
      grad.addColorStop(1, "rgba(255,255,255,0)");
      ctx.strokeStyle = grad;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(star.x, star.y);
      ctx.lineTo(star.x + star.length, star.y - star.length / 2);
      ctx.stroke();
    }
  }

  function floor(x, height) {
    this.x = x;
    this.width = 700;
    this.height = height;
  }

  var world = {
    height: 480,
    width: 640,
    gravity: 6,
    highestFloor: 240,
    speed: 5,
    distanceTravelled: 0,
    maxSpeed: 1000000000000,
    tilesPassed: 0,
    autoScroll: true,
    floorTiles: [new floor(0, 140)],
    stop: function () {
      this.autoScroll = false;
    },
    moveFloor: function () {
      for (let index in this.floorTiles) {
        var tile = this.floorTiles[index];
        tile.x -= this.speed;
        this.distanceTravelled += this.speed;
      }
    },
    tick: function () {
      if (!this.autoScroll) return;
      this.cleanOldTiles();
      this.addFutureTiles();
      this.moveFloor();
    },
    draw: function () {
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, this.width, this.height);

      drawStars();
      updateShootingStars();
      drawShootingStars();

      for (let index in this.floorTiles) {
        var tile = this.floorTiles[index];
        var y = world.height - tile.height;

        ctx.fillStyle = "gray";
        ctx.fillRect(tile.x, y, tile.width, tile.height);

        ctx.fillStyle = "white";
        ctx.font = "28px Arial";
        ctx.fillText("Speed: " + this.speed, 10, 40);
        ctx.fillText("Distance Travelled: " + this.distanceTravelled, 10, 75);
      }
    },
    addFutureTiles: function () {
      if (this.floorTiles.length >= 3) return;
      var previousTile = this.floorTiles[this.floorTiles.length - 1];
      var biggestJumpableHeight = previousTile.height + player.height * 2;
      if (biggestJumpableHeight > this.highestFloor) {
        biggestJumpableHeight = this.highestFloor;
      }

      var minHeightDiff = 20;
      var randomHeight;

      do {
        randomHeight = Math.floor(Math.random() * biggestJumpableHeight) + player.height;
      } while (Math.abs(randomHeight - previousTile.height) < minHeightDiff);

      var leftValue = previousTile.x + previousTile.width;
      var next = new floor(leftValue, randomHeight);
      this.floorTiles.push(next);
    },
    cleanOldTiles: function () {
      for (let index in this.floorTiles) {
        if (this.floorTiles[index].x <= -this.floorTiles[index].width) {
          this.floorTiles.splice(index, 1);
          this.tilesPassed++;
          if (this.tilesPassed % 3 === 0 && this.speed < this.maxSpeed) {
            this.speed++;
          }
        }
      }
    },
    getDistanceToFloor: function (playerX) {
      for (let index in this.floorTiles) {
        var tile = this.floorTiles[index];
        if (tile.x <= playerX && tile.x + tile.width >= playerX) {
          return tile.height;
        }
      }
      return -1;
    },
    reset: function() {
      this.speed = 5;
      this.distanceTravelled = 0;
      this.tilesPassed = 0;
      this.autoScroll = true;
      this.floorTiles = [new floor(0, 140)];
    }
  };

  var player = {
    x: 160,
    y: 340,
    height: 20,
    width: 20,
    velocityY: 0,
    gravity: 0.5,
    jumpImpulse: -7,
    maxJumpHoldFrames: 10,
    jumpHoldCounter: 0,
    jumping: false,
    canControl: true,

    jump: function () {
      if (!this.canControl) return;
      var floorHeight = world.getDistanceToFloor(this.x);
      var onTheFloor = this.y >= world.height - floorHeight;
      if (onTheFloor && !this.jumping) {
        this.velocityY = this.jumpImpulse;
        this.jumping = true;
        this.jumpHoldCounter = 0;
      }
    },

    releaseJump: function () {
      this.jumping = false;
    },

    keypress: function (keyInfo) {
      if (keyInfo.code === "KeyR") {
        window.location.reload();
        return;
      }
      if (keyInfo.code === "Space") {
        this.jump();
      }
    },

    keyup: function (keyInfo) {
      if (keyInfo.code === "Space") {
        this.releaseJump();
      }
    },

    getDistanceFor: function (x) {
      var platformBelow = world.getDistanceToFloor(x);
      return world.height - this.y - platformBelow;
    },

    applyGravity: function () {
      this.currentDistanceAboveGround = this.getDistanceFor(this.x);
      var rightHandSideDistance = this.getDistanceFor(this.x + this.width);
      if (this.currentDistanceAboveGround < 0 || rightHandSideDistance < 0) {
        world.stop();
        this.canControl = false;
      }
    },

    processGravity: function () {
      if (this.jumping && this.jumpHoldCounter < this.maxJumpHoldFrames) {
        this.velocityY += -0.2;
        this.jumpHoldCounter++;
      }

      this.velocityY += this.gravity;
      this.y += this.velocityY;

      var floorHeight = world.getDistanceToFloor(this.x);
      var topYofPlatform = world.height - floorHeight;

      if (this.y > topYofPlatform) {
        this.y = topYofPlatform;
        this.velocityY = 0;
        this.jumping = false;
      }
    },

    tick: function () {
      this.processGravity();
      this.applyGravity();
    },

    draw: function () {
      ctx.drawImage(
        goatImg,
        this.x,
        this.y - this.height,
        this.width,
        this.height
      );
    },

    reset: function() {
      this.x = 160;
      this.y = 340;
      this.velocityY = 0;
      this.jumping = false;
      this.canControl = true;
    }
  };

  // Input handlers for the game
  window.addEventListener("keydown", function (e) {
    if (!isGameStarted) return;
    player.keypress(e);
  });

  window.addEventListener("keyup", function (e) {
    if (!isGameStarted) return;
    player.keyup(e);
  });

  document.getElementById('jumpBtn').addEventListener('touchstart', function (e) {
    e.preventDefault();
    if (!isGameStarted) return;
    player.jump();
  });

  document.getElementById('jumpBtn').addEventListener('touchend', function (e) {
    e.preventDefault();
    if (!isGameStarted) return;
    player.releaseJump();
  });

  document.getElementById('restartBtn').addEventListener('touchstart', function (e) {
    e.preventDefault();
    if (!isGameStarted) return;
    restartGame();
  });

  // Main menu buttons
  var menu = document.getElementById('menu');
  var jumpBtn = document.getElementById('jumpBtn');
  var restartBtn = document.getElementById('restartBtn');

  var levelButtons = document.querySelectorAll('.level-btn');
  levelButtons.forEach(button => {
    button.addEventListener('click', function() {
      var selected = this.getAttribute('data-level');
      selectLevel(selected);
    });
  });

  function selectLevel(level) {
    currentLevel = level;
    if (level === "moon") {
      // Hide menu, show game canvas and buttons
      menu.style.display = "none";
      canvas.style.display = "block";
      jumpBtn.style.display = "block";
      restartBtn.style.display = "block";
      startMoonGame();
    } else {
      alert(`Level "${level.charAt(0).toUpperCase() + level.slice(1)}" coming soon!`);
    }
  }

  function startMoonGame() {
    isGameStarted = true;
    world.reset();
    player.reset();
    initStars();
    shootingStars = [];
    shootingTimer = 0;
    tick();
  }

  function restartGame() {
    world.reset();
    player.reset();
    isGameStarted = true;
  }

  function tick() {
    if (isGameStarted) {
      player.tick();
      world.tick();
      world.draw();
      player.draw();
      requestAnimationFrame(tick);
    }
  }

</script>

</body>
</html>
